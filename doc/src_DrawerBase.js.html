<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>src/DrawerBase.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ArrayHelper.html">ArrayHelper</a><ul class='methods'><li data-type='method'><a href="ArrayHelper.html#.clone">clone</a></li><li data-type='method'><a href="ArrayHelper.html#.contains">contains</a></li><li data-type='method'><a href="ArrayHelper.html#.containsAll">containsAll</a></li><li data-type='method'><a href="ArrayHelper.html#.count">count</a></li><li data-type='method'><a href="ArrayHelper.html#.deepCopy">deepCopy</a></li><li data-type='method'><a href="ArrayHelper.html#.each">each</a></li><li data-type='method'><a href="ArrayHelper.html#.equals">equals</a></li><li data-type='method'><a href="ArrayHelper.html#.get">get</a></li><li data-type='method'><a href="ArrayHelper.html#.intersection">intersection</a></li><li data-type='method'><a href="ArrayHelper.html#.merge">merge</a></li><li data-type='method'><a href="ArrayHelper.html#.print">print</a></li><li data-type='method'><a href="ArrayHelper.html#.remove">remove</a></li><li data-type='method'><a href="ArrayHelper.html#.removeAll">removeAll</a></li><li data-type='method'><a href="ArrayHelper.html#.removeUnique">removeUnique</a></li><li data-type='method'><a href="ArrayHelper.html#.sortByAtomicNumberDesc">sortByAtomicNumberDesc</a></li><li data-type='method'><a href="ArrayHelper.html#.toggle">toggle</a></li><li data-type='method'><a href="ArrayHelper.html#.unique">unique</a></li></ul></li><li><a href="Atom.html">Atom</a><ul class='methods'><li data-type='method'><a href="Atom.html#addAnchoredRing">addAnchoredRing</a></li><li data-type='method'><a href="Atom.html#addNeighbouringElement">addNeighbouringElement</a></li><li data-type='method'><a href="Atom.html#attachPseudoElement">attachPseudoElement</a></li><li data-type='method'><a href="Atom.html#backupRings">backupRings</a></li><li data-type='method'><a href="Atom.html#getAtomicNumber">getAtomicNumber</a></li><li data-type='method'><a href="Atom.html#getAttachedPseudoElements">getAttachedPseudoElements</a></li><li data-type='method'><a href="Atom.html#getAttachedPseudoElementsCount">getAttachedPseudoElementsCount</a></li><li data-type='method'><a href="Atom.html#getMaxBonds">getMaxBonds</a></li><li data-type='method'><a href="Atom.html#getRingbondCount">getRingbondCount</a></li><li data-type='method'><a href="Atom.html#haveCommonRingbond">haveCommonRingbond</a></li><li data-type='method'><a href="Atom.html#isHeteroAtom">isHeteroAtom</a></li><li data-type='method'><a href="Atom.html#neighbouringElementsEqual">neighbouringElementsEqual</a></li><li data-type='method'><a href="Atom.html#restoreRings">restoreRings</a></li></ul></li><li><a href="CanvasWrapper.html">CanvasWrapper</a><ul class='methods'><li data-type='method'><a href="CanvasWrapper.html#clear">clear</a></li><li data-type='method'><a href="CanvasWrapper.html#drawAromaticityRing">drawAromaticityRing</a></li><li data-type='method'><a href="CanvasWrapper.html#drawBall">drawBall</a></li><li data-type='method'><a href="CanvasWrapper.html#drawCircle">drawCircle</a></li><li data-type='method'><a href="CanvasWrapper.html#drawDashedWedge">drawDashedWedge</a></li><li data-type='method'><a href="CanvasWrapper.html#drawDebugPoint">drawDebugPoint</a></li><li data-type='method'><a href="CanvasWrapper.html#drawDebugText">drawDebugText</a></li><li data-type='method'><a href="CanvasWrapper.html#drawLine">drawLine</a></li><li data-type='method'><a href="CanvasWrapper.html#drawPoint">drawPoint</a></li><li data-type='method'><a href="CanvasWrapper.html#drawText">drawText</a></li><li data-type='method'><a href="CanvasWrapper.html#drawWedge">drawWedge</a></li><li data-type='method'><a href="CanvasWrapper.html#getChargeText">getChargeText</a></li><li data-type='method'><a href="CanvasWrapper.html#getColor">getColor</a></li><li data-type='method'><a href="CanvasWrapper.html#reset">reset</a></li><li data-type='method'><a href="CanvasWrapper.html#scale">scale</a></li><li data-type='method'><a href="CanvasWrapper.html#setTheme">setTheme</a></li><li data-type='method'><a href="CanvasWrapper.html#updateSize">updateSize</a></li></ul></li><li><a href="Drawer.html">Drawer</a><ul class='methods'><li data-type='method'><a href="Drawer.html#draw">draw</a></li><li data-type='method'><a href="Drawer.html#getMolecularFormula">getMolecularFormula</a></li><li data-type='method'><a href="Drawer.html#getTotalOverlapScore">getTotalOverlapScore</a></li></ul></li><li><a href="DrawerBase.html">DrawerBase</a><ul class='methods'><li data-type='method'><a href="DrawerBase.html#addRing">addRing</a></li><li data-type='method'><a href="DrawerBase.html#addRingConnection">addRingConnection</a></li><li data-type='method'><a href="DrawerBase.html#annotateStereochemistry">annotateStereochemistry</a></li><li data-type='method'><a href="DrawerBase.html#areVerticesInSameRing">areVerticesInSameRing</a></li><li data-type='method'><a href="DrawerBase.html#backupRingInformation">backupRingInformation</a></li><li data-type='method'><a href="DrawerBase.html#chooseSide">chooseSide</a></li><li data-type='method'><a href="DrawerBase.html#createBridgedRing">createBridgedRing</a></li><li data-type='method'><a href="DrawerBase.html#createNextBond">createNextBond</a></li><li data-type='method'><a href="DrawerBase.html#createRing">createRing</a></li><li data-type='method'><a href="DrawerBase.html#draw">draw</a></li><li data-type='method'><a href="DrawerBase.html#drawEdge">drawEdge</a></li><li data-type='method'><a href="DrawerBase.html#drawEdges">drawEdges</a></li><li data-type='method'><a href="DrawerBase.html#drawVertices">drawVertices</a></li><li data-type='method'><a href="DrawerBase.html#edgeRingCount">edgeRingCount</a></li><li data-type='method'><a href="DrawerBase.html#getBridgedRingRings">getBridgedRingRings</a></li><li data-type='method'><a href="DrawerBase.html#getBridgedRings">getBridgedRings</a></li><li data-type='method'><a href="DrawerBase.html#getClosestVertex">getClosestVertex</a></li><li data-type='method'><a href="DrawerBase.html#getCommonRingbondNeighbour">getCommonRingbondNeighbour</a></li><li data-type='method'><a href="DrawerBase.html#getCommonRings">getCommonRings</a></li><li data-type='method'><a href="DrawerBase.html#getCurrentCenterOfMass">getCurrentCenterOfMass</a></li><li data-type='method'><a href="DrawerBase.html#getCurrentCenterOfMassInNeigbourhood">getCurrentCenterOfMassInNeigbourhood</a></li><li data-type='method'><a href="DrawerBase.html#getEdgeNormals">getEdgeNormals</a></li><li data-type='method'><a href="DrawerBase.html#getFusedRings">getFusedRings</a></li><li data-type='method'><a href="DrawerBase.html#getHeavyAtomCount">getHeavyAtomCount</a></li><li data-type='method'><a href="DrawerBase.html#getLargestOrAromaticCommonRing">getLargestOrAromaticCommonRing</a></li><li data-type='method'><a href="DrawerBase.html#getLastAngle">getLastAngle</a></li><li data-type='method'><a href="DrawerBase.html#getMolecularFormula">getMolecularFormula</a></li><li data-type='method'><a href="DrawerBase.html#getNonRingNeighbours">getNonRingNeighbours</a></li><li data-type='method'><a href="DrawerBase.html#getOverlapScore">getOverlapScore</a></li><li data-type='method'><a href="DrawerBase.html#getRing">getRing</a></li><li data-type='method'><a href="DrawerBase.html#getRingbondType">getRingbondType</a></li><li data-type='method'><a href="DrawerBase.html#getRingConnection">getRingConnection</a></li><li data-type='method'><a href="DrawerBase.html#getRingConnections">getRingConnections</a></li><li data-type='method'><a href="DrawerBase.html#getRingCount">getRingCount</a></li><li data-type='method'><a href="DrawerBase.html#getSpiros">getSpiros</a></li><li data-type='method'><a href="DrawerBase.html#getSubringCenter">getSubringCenter</a></li><li data-type='method'><a href="DrawerBase.html#getSubtreeOverlapScore">getSubtreeOverlapScore</a></li><li data-type='method'><a href="DrawerBase.html#getTotalOverlapScore">getTotalOverlapScore</a></li><li data-type='method'><a href="DrawerBase.html#getVerticesAt">getVerticesAt</a></li><li data-type='method'><a href="DrawerBase.html#hasBridgedRing">hasBridgedRing</a></li><li data-type='method'><a href="DrawerBase.html#initPseudoElements">initPseudoElements</a></li><li data-type='method'><a href="DrawerBase.html#initRings">initRings</a></li><li data-type='method'><a href="DrawerBase.html#isEdgeInRing">isEdgeInRing</a></li><li data-type='method'><a href="DrawerBase.html#isEdgeRotatable">isEdgeRotatable</a></li><li data-type='method'><a href="DrawerBase.html#isPartOfBridgedRing">isPartOfBridgedRing</a></li><li data-type='method'><a href="DrawerBase.html#isPointInRing">isPointInRing</a></li><li data-type='method'><a href="DrawerBase.html#isRingAromatic">isRingAromatic</a></li><li data-type='method'><a href="DrawerBase.html#position">position</a></li><li data-type='method'><a href="DrawerBase.html#printRingInfo">printRingInfo</a></li><li data-type='method'><a href="DrawerBase.html#removeRing">removeRing</a></li><li data-type='method'><a href="DrawerBase.html#removeRingConnection">removeRingConnection</a></li><li data-type='method'><a href="DrawerBase.html#removeRingConnectionsBetween">removeRingConnectionsBetween</a></li><li data-type='method'><a href="DrawerBase.html#resolvePrimaryOverlaps">resolvePrimaryOverlaps</a></li><li data-type='method'><a href="DrawerBase.html#resolveSecondaryOverlaps">resolveSecondaryOverlaps</a></li><li data-type='method'><a href="DrawerBase.html#restoreRingInformation">restoreRingInformation</a></li><li data-type='method'><a href="DrawerBase.html#rotateDrawing">rotateDrawing</a></li><li data-type='method'><a href="DrawerBase.html#rotateSubtree">rotateSubtree</a></li><li data-type='method'><a href="DrawerBase.html#setRingCenter">setRingCenter</a></li><li data-type='method'><a href="DrawerBase.html#visitStereochemistry">visitStereochemistry</a></li></ul></li><li><a href="Edge.html">Edge</a><ul class='methods'><li data-type='method'><a href="Edge.html#setBondType">setBondType</a></li></ul></li><li><a href="GaussDrawer.html">GaussDrawer</a><ul class='methods'><li data-type='method'><a href="GaussDrawer.html#draw">draw</a></li><li data-type='method'><a href="GaussDrawer.html#getImage">getImage</a></li><li data-type='method'><a href="GaussDrawer.html#getSVG">getSVG</a></li><li data-type='method'><a href="GaussDrawer.html#setPixel">setPixel</a></li></ul></li><li><a href="Graph.html">Graph</a><ul class='methods'><li data-type='method'><a href="Graph.html#._ccCountDfs">_ccCountDfs</a></li><li data-type='method'><a href="Graph.html#._ccGetDfs">_ccGetDfs</a></li><li data-type='method'><a href="Graph.html#.getConnectedComponentCount">getConnectedComponentCount</a></li><li data-type='method'><a href="Graph.html#.getConnectedComponents">getConnectedComponents</a></li><li data-type='method'><a href="Graph.html#_bridgeDfs">_bridgeDfs</a></li><li data-type='method'><a href="Graph.html#_init">_init</a></li><li data-type='method'><a href="Graph.html#addEdge">addEdge</a></li><li data-type='method'><a href="Graph.html#addVertex">addVertex</a></li><li data-type='method'><a href="Graph.html#clear">clear</a></li><li data-type='method'><a href="Graph.html#getAdjacencyList">getAdjacencyList</a></li><li data-type='method'><a href="Graph.html#getAdjacencyMatrix">getAdjacencyMatrix</a></li><li data-type='method'><a href="Graph.html#getBridges">getBridges</a></li><li data-type='method'><a href="Graph.html#getComponentsAdjacencyMatrix">getComponentsAdjacencyMatrix</a></li><li data-type='method'><a href="Graph.html#getDistanceMatrix">getDistanceMatrix</a></li><li data-type='method'><a href="Graph.html#getEdge">getEdge</a></li><li data-type='method'><a href="Graph.html#getEdgeList">getEdgeList</a></li><li data-type='method'><a href="Graph.html#getEdges">getEdges</a></li><li data-type='method'><a href="Graph.html#getSubgraphAdjacencyList">getSubgraphAdjacencyList</a></li><li data-type='method'><a href="Graph.html#getSubgraphAdjacencyMatrix">getSubgraphAdjacencyMatrix</a></li><li data-type='method'><a href="Graph.html#getSubgraphDistanceMatrix">getSubgraphDistanceMatrix</a></li><li data-type='method'><a href="Graph.html#getTreeDepth">getTreeDepth</a></li><li data-type='method'><a href="Graph.html#getVertexList">getVertexList</a></li><li data-type='method'><a href="Graph.html#hasEdge">hasEdge</a></li><li data-type='method'><a href="Graph.html#kkLayout">kkLayout</a></li><li data-type='method'><a href="Graph.html#traverseBF">traverseBF</a></li><li data-type='method'><a href="Graph.html#traverseTree">traverseTree</a></li></ul></li><li><a href="Line.html">Line</a><ul class='methods'><li data-type='method'><a href="Line.html#clone">clone</a></li><li data-type='method'><a href="Line.html#getAngle">getAngle</a></li><li data-type='method'><a href="Line.html#getLeftChiral">getLeftChiral</a></li><li data-type='method'><a href="Line.html#getLeftElement">getLeftElement</a></li><li data-type='method'><a href="Line.html#getLeftVector">getLeftVector</a></li><li data-type='method'><a href="Line.html#getLength">getLength</a></li><li data-type='method'><a href="Line.html#getRightChiral">getRightChiral</a></li><li data-type='method'><a href="Line.html#getRightElement">getRightElement</a></li><li data-type='method'><a href="Line.html#getRightVector">getRightVector</a></li><li data-type='method'><a href="Line.html#rotate">rotate</a></li><li data-type='method'><a href="Line.html#rotateToXAxis">rotateToXAxis</a></li><li data-type='method'><a href="Line.html#setLeftVector">setLeftVector</a></li><li data-type='method'><a href="Line.html#setRightVector">setRightVector</a></li><li data-type='method'><a href="Line.html#shorten">shorten</a></li><li data-type='method'><a href="Line.html#shortenFrom">shortenFrom</a></li><li data-type='method'><a href="Line.html#shortenLeft">shortenLeft</a></li><li data-type='method'><a href="Line.html#shortenRight">shortenRight</a></li><li data-type='method'><a href="Line.html#shortenTo">shortenTo</a></li></ul></li><li><a href="MathHelper.html">MathHelper</a><ul class='methods'><li data-type='method'><a href="MathHelper.html#.apothem">apothem</a></li><li data-type='method'><a href="MathHelper.html#.centralAngle">centralAngle</a></li><li data-type='method'><a href="MathHelper.html#.innerAngle">innerAngle</a></li><li data-type='method'><a href="MathHelper.html#.meanAngle">meanAngle</a></li><li data-type='method'><a href="MathHelper.html#.parityOfPermutation">parityOfPermutation</a></li><li data-type='method'><a href="MathHelper.html#.polyCircumradius">polyCircumradius</a></li><li data-type='method'><a href="MathHelper.html#.round">round</a></li><li data-type='method'><a href="MathHelper.html#.toDeg">toDeg</a></li><li data-type='method'><a href="MathHelper.html#.toRad">toRad</a></li></ul></li><li><a href="Reaction.html">Reaction</a></li><li><a href="ReactionDrawer.html">ReactionDrawer</a><ul class='methods'><li data-type='method'><a href="ReactionDrawer.html#draw">draw</a></li></ul></li><li><a href="Ring.html">Ring</a><ul class='methods'><li data-type='method'><a href="Ring.html#clone">clone</a></li><li data-type='method'><a href="Ring.html#contains">contains</a></li><li data-type='method'><a href="Ring.html#eachMember">eachMember</a></li><li data-type='method'><a href="Ring.html#getAngle">getAngle</a></li><li data-type='method'><a href="Ring.html#getDoubleBondCount">getDoubleBondCount</a></li><li data-type='method'><a href="Ring.html#getOrderedNeighbours">getOrderedNeighbours</a></li><li data-type='method'><a href="Ring.html#getPolygon">getPolygon</a></li><li data-type='method'><a href="Ring.html#getSize">getSize</a></li><li data-type='method'><a href="Ring.html#isBenzeneLike">isBenzeneLike</a></li></ul></li><li><a href="RingConnection.html">RingConnection</a><ul class='methods'><li data-type='method'><a href="RingConnection.html#.getNeighbours">getNeighbours</a></li><li data-type='method'><a href="RingConnection.html#.getVertices">getVertices</a></li><li data-type='method'><a href="RingConnection.html#.isBridge">isBridge</a></li><li data-type='method'><a href="RingConnection.html#addVertex">addVertex</a></li><li data-type='method'><a href="RingConnection.html#containsRing">containsRing</a></li><li data-type='method'><a href="RingConnection.html#isBridge">isBridge</a></li><li data-type='method'><a href="RingConnection.html#updateOther">updateOther</a></li></ul></li><li><a href="SSSR.html">SSSR</a><ul class='methods'><li data-type='method'><a href="SSSR.html#.areSetsEqual">areSetsEqual</a></li><li data-type='method'><a href="SSSR.html#.bondsToAtoms">bondsToAtoms</a></li><li data-type='method'><a href="SSSR.html#.getBondCount">getBondCount</a></li><li data-type='method'><a href="SSSR.html#.getEdgeCount">getEdgeCount</a></li><li data-type='method'><a href="SSSR.html#.getEdgeList">getEdgeList</a></li><li data-type='method'><a href="SSSR.html#.getPathIncludedDistanceMatrices">getPathIncludedDistanceMatrices</a></li><li data-type='method'><a href="SSSR.html#.getRingCandidates">getRingCandidates</a></li><li data-type='method'><a href="SSSR.html#.getRings">getRings</a></li><li data-type='method'><a href="SSSR.html#.getSSSR">getSSSR</a></li><li data-type='method'><a href="SSSR.html#.isSupersetOf">isSupersetOf</a></li><li data-type='method'><a href="SSSR.html#.matrixToString">matrixToString</a></li><li data-type='method'><a href="SSSR.html#.pathSetsContain">pathSetsContain</a></li></ul></li><li><a href="Vector2.html">Vector2</a><ul class='methods'><li data-type='method'><a href="Vector2.html#add">add</a></li><li data-type='method'><a href="Vector2.html#angle">angle</a></li><li data-type='method'><a href="Vector2.html#clockwise">clockwise</a></li><li data-type='method'><a href="Vector2.html#clone">clone</a></li><li data-type='method'><a href="Vector2.html#distance">distance</a></li><li data-type='method'><a href="Vector2.html#distanceSq">distanceSq</a></li><li data-type='method'><a href="Vector2.html#divide">divide</a></li><li data-type='method'><a href="Vector2.html#getRotateAwayFromAngle">getRotateAwayFromAngle</a></li><li data-type='method'><a href="Vector2.html#getRotateToAngle">getRotateToAngle</a></li><li data-type='method'><a href="Vector2.html#getRotateTowardsAngle">getRotateTowardsAngle</a></li><li data-type='method'><a href="Vector2.html#invert">invert</a></li><li data-type='method'><a href="Vector2.html#isInPolygon">isInPolygon</a></li><li data-type='method'><a href="Vector2.html#length">length</a></li><li data-type='method'><a href="Vector2.html#lengthSq">lengthSq</a></li><li data-type='method'><a href="Vector2.html#multiply">multiply</a></li><li data-type='method'><a href="Vector2.html#multiplyScalar">multiplyScalar</a></li><li data-type='method'><a href="Vector2.html#normalize">normalize</a></li><li data-type='method'><a href="Vector2.html#normalized">normalized</a></li><li data-type='method'><a href="Vector2.html#relativeClockwise">relativeClockwise</a></li><li data-type='method'><a href="Vector2.html#rotate">rotate</a></li><li data-type='method'><a href="Vector2.html#rotateAround">rotateAround</a></li><li data-type='method'><a href="Vector2.html#rotateAwayFrom">rotateAwayFrom</a></li><li data-type='method'><a href="Vector2.html#rotateTo">rotateTo</a></li><li data-type='method'><a href="Vector2.html#sameSideAs">sameSideAs</a></li><li data-type='method'><a href="Vector2.html#subtract">subtract</a></li><li data-type='method'><a href="Vector2.html#toString">toString</a></li><li data-type='method'><a href="Vector2.html#whichSide">whichSide</a></li><li data-type='method'><a href="Vector2.html#.add">add</a></li><li data-type='method'><a href="Vector2.html#.angle">angle</a></li><li data-type='method'><a href="Vector2.html#.averageDirection">averageDirection</a></li><li data-type='method'><a href="Vector2.html#.divide">divide</a></li><li data-type='method'><a href="Vector2.html#.divideScalar">divideScalar</a></li><li data-type='method'><a href="Vector2.html#.dot">dot</a></li><li data-type='method'><a href="Vector2.html#.midpoint">midpoint</a></li><li data-type='method'><a href="Vector2.html#.multiply">multiply</a></li><li data-type='method'><a href="Vector2.html#.multiplyScalar">multiplyScalar</a></li><li data-type='method'><a href="Vector2.html#.normals">normals</a></li><li data-type='method'><a href="Vector2.html#.scalarProjection">scalarProjection</a></li><li data-type='method'><a href="Vector2.html#.subtract">subtract</a></li><li data-type='method'><a href="Vector2.html#.threePointangle">threePointangle</a></li><li data-type='method'><a href="Vector2.html#.units">units</a></li></ul></li><li><a href="Vertex.html">Vertex</a><ul class='methods'><li data-type='method'><a href="Vertex.html#addChild">addChild</a></li><li data-type='method'><a href="Vertex.html#addRingbondChild">addRingbondChild</a></li><li data-type='method'><a href="Vertex.html#clone">clone</a></li><li data-type='method'><a href="Vertex.html#equals">equals</a></li><li data-type='method'><a href="Vertex.html#getAngle">getAngle</a></li><li data-type='method'><a href="Vertex.html#getDrawnNeighbours">getDrawnNeighbours</a></li><li data-type='method'><a href="Vertex.html#getNeighbourCount">getNeighbourCount</a></li><li data-type='method'><a href="Vertex.html#getNeighbours">getNeighbours</a></li><li data-type='method'><a href="Vertex.html#getNextInRing">getNextInRing</a></li><li data-type='method'><a href="Vertex.html#getSpanningTreeNeighbours">getSpanningTreeNeighbours</a></li><li data-type='method'><a href="Vertex.html#getTextDirection">getTextDirection</a></li><li data-type='method'><a href="Vertex.html#isTerminal">isTerminal</a></li><li data-type='method'><a href="Vertex.html#setParentVertexId">setParentVertexId</a></li><li data-type='method'><a href="Vertex.html#setPosition">setPosition</a></li><li data-type='method'><a href="Vertex.html#setPositionFromVector">setPositionFromVector</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-test_generate-json.html">test/generate-json</a></li><li><a href="module-test_regression-runner.html">test/regression-runner</a><ul class='methods'><li data-type='method'><a href="module-test_regression-runner.html#~sanitizeSmiles">sanitizeSmiles</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#getChargeText">getChargeText</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">src/DrawerBase.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
const StereochemistryManager_1 = __importDefault(require("./StereochemistryManager"));
const OverlapResolutionManager_1 = __importDefault(require("./OverlapResolutionManager"));
const RingManager = require("./RingManager");
const MathHelper = require("./MathHelper");
const ArrayHelper = require("./ArrayHelper");
const Vector2 = require("./Vector2");
const Line = require("./Line");
const Atom = require("./Atom");
const CanvasWrapper = require("./CanvasWrapper");
const Graph = require("./Graph");
const ThemeManager = require("./ThemeManager");
const Options = require("./Options");
/**
 * The main class of the application representing the smiles drawer
 *
 * @property {Graph} graph The graph associated with this SmilesDrawer.Drawer instance.
 * @property {Number} ringIdCounter An internal counter to keep track of ring ids.
 * @property {Number} ringConnectionIdCounter An internal counter to keep track of ring connection ids.
 * @property {CanvasWrapper} canvasWrapper The CanvasWrapper associated with this SmilesDrawer.Drawer instance.
 * @property {Number} totalOverlapScore The current internal total overlap score.
 * @property {Object} defaultOptions The default options.
 * @property {Object} opts The merged options.
 * @property {Object} theme The current theme.
 */
class DrawerBase {
    /**
     * The constructor for the class SmilesDrawer.
     *
     * @param {Object} options An object containing custom values for different options. It is merged with the default options.
     */
    constructor(options) {
        this.ringManager = new RingManager(this);
        this.stereochemistryManager = new StereochemistryManager_1.default(this);
        this.overlapResolver = new OverlapResolutionManager_1.default(this);
        this.graph = null;
        this.doubleBondConfigCount = 0;
        this.doubleBondConfig = null;
        this.ringIdCounter = 0;
        this.ringConnectionIdCounter = 0;
        this.canvasWrapper = null;
        this.totalOverlapScore = 0;
        this.defaultOptions = {
            width: 500,
            height: 500,
            scale: 0.0,
            bondThickness: 1.0,
            bondLength: 30,
            shortBondLength: 0.8,
            bondSpacing: 0.17 * 30,
            atomVisualization: 'default',
            isomeric: true,
            debug: false,
            terminalCarbons: false,
            explicitHydrogens: true,
            overlapSensitivity: 0.42,
            overlapResolutionIterations: 1,
            compactDrawing: true,
            fontFamily: 'Arial, Helvetica, sans-serif',
            fontSizeLarge: 11,
            fontSizeSmall: 3,
            padding: 10.0,
            experimentalSSSR: false,
            kkThreshold: 0.1,
            kkInnerThreshold: 0.1,
            kkMaxIteration: 20000,
            kkMaxInnerIteration: 50,
            kkMaxEnergy: 1e9,
            weights: {
                colormap: null,
                additionalPadding: 20.0,
                sigma: 10,
                interval: 0.0,
                opacity: 1.0,
            },
            themes: {
                dark: {
                    C: '#fff',
                    O: '#e74c3c',
                    N: '#3498db',
                    F: '#27ae60',
                    CL: '#16a085',
                    BR: '#d35400',
                    I: '#8e44ad',
                    P: '#d35400',
                    S: '#f1c40f',
                    B: '#e67e22',
                    SI: '#e67e22',
                    H: '#aaa',
                    BACKGROUND: '#141414'
                },
                light: {
                    C: '#222',
                    O: '#e74c3c',
                    N: '#3498db',
                    F: '#27ae60',
                    CL: '#16a085',
                    BR: '#d35400',
                    I: '#8e44ad',
                    P: '#d35400',
                    S: '#f1c40f',
                    B: '#e67e22',
                    SI: '#e67e22',
                    H: '#666',
                    BACKGROUND: '#fff'
                },
                oldschool: {
                    C: '#000',
                    O: '#000',
                    N: '#000',
                    F: '#000',
                    CL: '#000',
                    BR: '#000',
                    I: '#000',
                    P: '#000',
                    S: '#000',
                    B: '#000',
                    SI: '#000',
                    H: '#000',
                    BACKGROUND: '#fff'
                },
                "solarized": {
                    C: "#586e75",
                    O: "#dc322f",
                    N: "#268bd2",
                    F: "#859900",
                    CL: "#16a085",
                    BR: "#cb4b16",
                    I: "#6c71c4",
                    P: "#d33682",
                    S: "#b58900",
                    B: "#2aa198",
                    SI: "#2aa198",
                    H: "#657b83",
                    BACKGROUND: "#fff"
                },
                "solarized-dark": {
                    C: "#93a1a1",
                    O: "#dc322f",
                    N: "#268bd2",
                    F: "#859900",
                    CL: "#16a085",
                    BR: "#cb4b16",
                    I: "#6c71c4",
                    P: "#d33682",
                    S: "#b58900",
                    B: "#2aa198",
                    SI: "#2aa198",
                    H: "#839496",
                    BACKGROUND: "#fff"
                },
                "matrix": {
                    C: "#678c61",
                    O: "#2fc079",
                    N: "#4f7e7e",
                    F: "#90d762",
                    CL: "#82d967",
                    BR: "#23755a",
                    I: "#409931",
                    P: "#c1ff8a",
                    S: "#faff00",
                    B: "#50b45a",
                    SI: "#409931",
                    H: "#426644",
                    BACKGROUND: "#fff"
                },
                "github": {
                    C: "#24292f",
                    O: "#cf222e",
                    N: "#0969da",
                    F: "#2da44e",
                    CL: "#6fdd8b",
                    BR: "#bc4c00",
                    I: "#8250df",
                    P: "#bf3989",
                    S: "#d4a72c",
                    B: "#fb8f44",
                    SI: "#bc4c00",
                    H: "#57606a",
                    BACKGROUND: "#fff"
                },
                "carbon": {
                    C: "#161616",
                    O: "#da1e28",
                    N: "#0f62fe",
                    F: "#198038",
                    CL: "#007d79",
                    BR: "#fa4d56",
                    I: "#8a3ffc",
                    P: "#ff832b",
                    S: "#f1c21b",
                    B: "#8a3800",
                    SI: "#e67e22",
                    H: "#525252",
                    BACKGROUND: "#fff"
                },
                "cyberpunk": {
                    C: "#ea00d9",
                    O: "#ff3131",
                    N: "#0abdc6",
                    F: "#00ff9f",
                    CL: "#00fe00",
                    BR: "#fe9f20",
                    I: "#ff00ff",
                    P: "#fe7f00",
                    S: "#fcee0c",
                    B: "#ff00ff",
                    SI: "#ffffff",
                    H: "#913cb1",
                    BACKGROUND: "#fff"
                },
                "gruvbox": {
                    C: "#665c54",
                    O: "#cc241d",
                    N: "#458588",
                    F: "#98971a",
                    CL: "#79740e",
                    BR: "#d65d0e",
                    I: "#b16286",
                    P: "#af3a03",
                    S: "#d79921",
                    B: "#689d6a",
                    SI: "#427b58",
                    H: "#7c6f64",
                    BACKGROUND: "#fbf1c7"
                },
                "gruvbox-dark": {
                    C: "#ebdbb2",
                    O: "#cc241d",
                    N: "#458588",
                    F: "#98971a",
                    CL: "#b8bb26",
                    BR: "#d65d0e",
                    I: "#b16286",
                    P: "#fe8019",
                    S: "#d79921",
                    B: "#8ec07c",
                    SI: "#83a598",
                    H: "#bdae93",
                    BACKGROUND: "#282828"
                },
                custom: {
                    C: '#222',
                    O: '#e74c3c',
                    N: '#3498db',
                    F: '#27ae60',
                    CL: '#16a085',
                    BR: '#d35400',
                    I: '#8e44ad',
                    P: '#d35400',
                    S: '#f1c40f',
                    B: '#e67e22',
                    SI: '#e67e22',
                    H: '#666',
                    BACKGROUND: '#fff'
                },
            }
        };
        this.opts = Options.extend(true, this.defaultOptions, options);
        this.opts.halfBondSpacing = this.opts.bondSpacing / 2.0;
        this.opts.bondLengthSq = this.opts.bondLength * this.opts.bondLength;
        this.opts.halfFontSizeLarge = this.opts.fontSizeLarge / 2.0;
        this.opts.quarterFontSizeLarge = this.opts.fontSizeLarge / 4.0;
        this.opts.fifthFontSizeSmall = this.opts.fontSizeSmall / 5.0;
        // Set the default theme.
        this.theme = this.opts.themes.dark;
    }
    /**
     * Draws the parsed smiles data to a canvas element.
     *
     * @param {Object} data The tree returned by the smiles parser.
     * @param {(String|HTMLCanvasElement)} target The id of the HTML canvas element the structure is drawn to - or the element itself.
     * @param {String} themeName='dark' The name of the theme to use. Built-in themes are 'light' and 'dark'.
     * @param {Boolean} infoOnly=false Only output info on the molecule without drawing anything to the canvas.
     */
    draw(data, target, themeName = 'light', infoOnly = false) {
        this.initDraw(data, themeName, infoOnly, null);
        if (!this.infoOnly) {
            this.themeManager = new ThemeManager(this.opts.themes, themeName);
            this.canvasWrapper = new CanvasWrapper(target, this.themeManager, this.opts);
        }
        if (!infoOnly) {
            this.processGraph();
            // Set the canvas to the appropriate size
            this.canvasWrapper.scale(this.graph.vertices);
            // Do the actual drawing
            this.drawEdges(this.opts.debug);
            this.drawVertices(this.opts.debug);
            this.canvasWrapper.reset();
            if (this.opts.debug) {
                console.log(this.graph);
                console.log(this.rings);
                console.log(this.ringConnections);
            }
        }
    }
    /**
     * Returns the number of rings this edge is a part of.
     *
     * @param {Number} edgeId The id of an edge.
     * @returns {Number} The number of rings the provided edge is part of.
     */
    edgeRingCount(edgeId) {
        return this.ringManager.edgeRingCount(edgeId);
    }
    /**
     * Returns an array containing the bridged rings associated with this  molecule.
     *
     * @returns {Ring[]} An array containing all bridged rings associated with this molecule.
     */
    getBridgedRings() {
        return this.ringManager.getBridgedRings();
    }
    /**
     * Returns an array containing all fused rings associated with this molecule.
     *
     * @returns {Ring[]} An array containing all fused rings associated with this molecule.
     */
    getFusedRings() {
        return this.ringManager.getFusedRings();
    }
    /**
     * Returns an array containing all spiros associated with this molecule.
     *
     * @returns {Ring[]} An array containing all spiros associated with this molecule.
     */
    getSpiros() {
        return this.ringManager.getSpiros();
    }
    /**
     * Returns a string containing a semicolon and new-line separated list of ring properties: Id; Members Count; Neighbours Count; IsSpiro; IsFused; IsBridged; Ring Count (subrings of bridged rings)
     *
     * @returns {String} A string as described in the method description.
     */
    printRingInfo() {
        return this.ringManager.printRingInfo();
    }
    /**
     * Rotates the drawing to make the widest dimension horizontal.
     */
    rotateDrawing() {
        // Rotate the vertices to make the molecule align horizontally
        // Find the longest distance
        let a = 0;
        let b = 0;
        let maxDist = 0;
        for (var i = 0; i &lt; this.graph.vertices.length; i++) {
            let vertexA = this.graph.vertices[i];
            if (!vertexA.value.isDrawn) {
                continue;
            }
            for (var j = i + 1; j &lt; this.graph.vertices.length; j++) {
                let vertexB = this.graph.vertices[j];
                if (!vertexB.value.isDrawn) {
                    continue;
                }
                let dist = vertexA.position.distanceSq(vertexB.position);
                if (dist > maxDist) {
                    maxDist = dist;
                    a = i;
                    b = j;
                }
            }
        }
        let angle = -Vector2.subtract(this.graph.vertices[a].position, this.graph.vertices[b].position).angle();
        if (!isNaN(angle)) {
            // Round to 30 degrees
            let remainder = angle % 0.523599;
            // Round either up or down in 30 degree steps
            if (remainder &lt; 0.2617995) {
                angle = angle - remainder;
            }
            else {
                angle += 0.523599 - remainder;
            }
            // Finally, rotate everything
            for (var i = 0; i &lt; this.graph.vertices.length; i++) {
                if (i === b) {
                    continue;
                }
                this.graph.vertices[i].position.rotateAround(angle, this.graph.vertices[b].position);
            }
            for (var i = 0; i &lt; this.rings.length; i++) {
                this.rings[i].center.rotateAround(angle, this.graph.vertices[b].position);
            }
        }
    }
    /**
     * Returns the total overlap score of the current molecule.
     *
     * @returns {Number} The overlap score.
     */
    getTotalOverlapScore() {
        return this.totalOverlapScore;
    }
    /**
     * Returns the ring count of the current molecule.
     *
     * @returns {Number} The ring count.
     */
    getRingCount() {
        return this.ringManager.getRingCount();
    }
    /**
     * Checks whether or not the current molecule  a bridged ring.
     *
     * @returns {Boolean} A boolean indicating whether or not the current molecule  a bridged ring.
     */
    hasBridgedRing() {
        return this.ringManager.hasBridgedRing();
    }
    /**
     * Returns the number of heavy atoms (non-hydrogen) in the current molecule.
     *
     * @returns {Number} The heavy atom count.
     */
    getHeavyAtomCount() {
        let hac = 0;
        for (var i = 0; i &lt; this.graph.vertices.length; i++) {
            if (this.graph.vertices[i].value.element !== 'H') {
                hac++;
            }
        }
        return hac;
    }
    /**
     * Returns the molecular formula of the loaded molecule as a string.
     *
     * @returns {String} The molecular formula.
     */
    getMolecularFormula(data = null) {
        let molecularFormula = '';
        let counts = new Map();
        let graph = data === null ? this.graph : new Graph(data, this.opts.isomeric);
        // Initialize element count
        for (var i = 0; i &lt; graph.vertices.length; i++) {
            let atom = graph.vertices[i].value;
            if (counts.has(atom.element)) {
                counts.set(atom.element, counts.get(atom.element) + 1);
            }
            else {
                counts.set(atom.element, 1);
            }
            // Hydrogens attached to a chiral center were added as vertices,
            // those in non chiral brackets are added here
            if (atom.bracket &amp;&amp; !atom.bracket.chirality) {
                if (counts.has('H')) {
                    counts.set('H', counts.get('H') + atom.bracket.hcount);
                }
                else {
                    counts.set('H', atom.bracket.hcount);
                }
            }
            // Add the implicit hydrogens according to valency, exclude
            // bracket atoms as they were handled and always have the number
            // of hydrogens specified explicitly
            if (!atom.bracket) {
                let nHydrogens = Atom.maxBonds[atom.element] - atom.bondCount;
                if (atom.isPartOfAromaticRing) {
                    nHydrogens--;
                }
                if (counts.has('H')) {
                    counts.set('H', counts.get('H') + nHydrogens);
                }
                else {
                    counts.set('H', nHydrogens);
                }
            }
        }
        if (counts.has('C')) {
            let count = counts.get('C');
            molecularFormula += 'C' + (count > 1 ? count : '');
            counts.delete('C');
        }
        if (counts.has('H')) {
            let count = counts.get('H');
            molecularFormula += 'H' + (count > 1 ? count : '');
            counts.delete('H');
        }
        let elements = Object.keys(Atom.atomicNumbers).sort();
        elements.map(e => {
            if (counts.has(e)) {
                let count = counts.get(e);
                molecularFormula += e + (count > 1 ? count : '');
            }
        });
        return molecularFormula;
    }
    /**
     * Returns the type of the ringbond (e.g. '=' for a double bond). The ringbond represents the break in a ring introduced when creating the MST. If the two vertices supplied as arguments are not part of a common ringbond, the method returns null.
     *
     * @param {Vertex} vertexA A vertex.
     * @param {Vertex} vertexB A vertex.
     * @returns {(String|null)} Returns the ringbond type or null, if the two supplied vertices are not connected by a ringbond.
     */
    getRingbondType(vertexA, vertexB) {
        return this.ringManager.getRingbondType(vertexA, vertexB);
    }
    initDraw(data, themeName, infoOnly, highlight_atoms) {
        this.data = data;
        this.infoOnly = infoOnly;
        this.ringIdCounter = 0;
        this.ringConnectionIdCounter = 0;
        this.graph = new Graph(data, this.opts.isomeric);
        this.rings = Array();
        this.ringConnections = Array();
        this.originalRings = Array();
        this.originalRingConnections = Array();
        this.bridgedRing = false;
        // Reset those, in case the previous drawn SMILES had a dangling \ or /
        this.doubleBondConfigCount = null;
        this.doubleBondConfig = null;
        this.highlight_atoms = highlight_atoms;
        this.initRings();
        this.initHydrogens();
    }
    processGraph() {
        this.position();
        // Restore the ring information (removes bridged rings and replaces them with the original, multiple, rings)
        this.restoreRingInformation();
        // Atoms bonded to the same ring atom
        this.resolvePrimaryOverlaps();
        let overlapScore = this.getOverlapScore();
        this.totalOverlapScore = this.getOverlapScore().total;
        for (var o = 0; o &lt; this.opts.overlapResolutionIterations; o++) {
            for (var i = 0; i &lt; this.graph.edges.length; i++) {
                let edge = this.graph.edges[i];
                if (this.isEdgeRotatable(edge)) {
                    let subTreeDepthA = this.graph.getTreeDepth(edge.sourceId, edge.targetId);
                    let subTreeDepthB = this.graph.getTreeDepth(edge.targetId, edge.sourceId);
                    // Only rotate the shorter subtree
                    let a = edge.targetId;
                    let b = edge.sourceId;
                    if (subTreeDepthA > subTreeDepthB) {
                        a = edge.sourceId;
                        b = edge.targetId;
                    }
                    let subTreeOverlap = this.getSubtreeOverlapScore(b, a, overlapScore.vertexScores);
                    if (subTreeOverlap.value > this.opts.overlapSensitivity) {
                        let vertexA = this.graph.vertices[a];
                        let vertexB = this.graph.vertices[b];
                        let neighboursB = vertexB.getNeighbours(a);
                        if (neighboursB.length === 1) {
                            let neighbour = this.graph.vertices[neighboursB[0]];
                            let angle = neighbour.position.getRotateAwayFromAngle(vertexA.position, vertexB.position, MathHelper.toRad(120));
                            this.rotateSubtree(neighbour.id, vertexB.id, angle, vertexB.position);
                            // If the new overlap is bigger, undo change
                            let newTotalOverlapScore = this.getOverlapScore().total;
                            if (newTotalOverlapScore > this.totalOverlapScore) {
                                this.rotateSubtree(neighbour.id, vertexB.id, -angle, vertexB.position);
                            }
                            else {
                                this.totalOverlapScore = newTotalOverlapScore;
                            }
                        }
                        else if (neighboursB.length === 2) {
                            // Switch places / sides
                            // If vertex a is in a ring, do nothing
                            if (vertexB.value.rings.length !== 0 &amp;&amp; vertexA.value.rings.length !== 0) {
                                continue;
                            }
                            let neighbourA = this.graph.vertices[neighboursB[0]];
                            let neighbourB = this.graph.vertices[neighboursB[1]];
                            if (neighbourA.value.rings.length === 1 &amp;&amp; neighbourB.value.rings.length === 1) {
                                // Both neighbours in same ring. TODO: does this create problems with wedges? (up = down and vice versa?)
                                if (neighbourA.value.rings[0] !== neighbourB.value.rings[0]) {
                                    continue;
                                }
                                // TODO: Rotate circle
                            }
                            else if (neighbourA.value.rings.length !== 0 || neighbourB.value.rings.length !== 0) {
                                continue;
                            }
                            else {
                                let angleA = neighbourA.position.getRotateAwayFromAngle(vertexA.position, vertexB.position, MathHelper.toRad(120));
                                let angleB = neighbourB.position.getRotateAwayFromAngle(vertexA.position, vertexB.position, MathHelper.toRad(120));
                                this.rotateSubtree(neighbourA.id, vertexB.id, angleA, vertexB.position);
                                this.rotateSubtree(neighbourB.id, vertexB.id, angleB, vertexB.position);
                                let newTotalOverlapScore = this.getOverlapScore().total;
                                if (newTotalOverlapScore > this.totalOverlapScore) {
                                    this.rotateSubtree(neighbourA.id, vertexB.id, -angleA, vertexB.position);
                                    this.rotateSubtree(neighbourB.id, vertexB.id, -angleB, vertexB.position);
                                }
                                else {
                                    this.totalOverlapScore = newTotalOverlapScore;
                                }
                            }
                        }
                        overlapScore = this.getOverlapScore();
                    }
                }
            }
        }
        this.resolveSecondaryOverlaps(overlapScore.scores);
        if (this.opts.isomeric) {
            this.annotateStereochemistry();
        }
        // Initialize pseudo elements or shortcuts
        if (this.opts.compactDrawing &amp;&amp; this.opts.atomVisualization === 'default') {
            this.initPseudoElements();
        }
        this.rotateDrawing();
    }
    /**
     * Initializes rings and ringbonds for the current molecule.
     */
    initRings() {
        this.ringManager.initRings();
    }
    initHydrogens() {
        // Do not draw hydrogens except when they are connected to a stereocenter connected to two or more rings.
        if (!this.opts.explicitHydrogens) {
            for (var i = 0; i &lt; this.graph.vertices.length; i++) {
                let vertex = this.graph.vertices[i];
                if (vertex.value.element !== 'H') {
                    continue;
                }
                // Hydrogens should have only one neighbour, so just take the first
                // Also set hasHydrogen true on connected atom
                let neighbour = this.graph.vertices[vertex.neighbours[0]];
                neighbour.value.hasHydrogen = true;
                if (!neighbour.value.isStereoCenter || neighbour.value.rings.length &lt; 2 &amp;&amp; !neighbour.value.bridgedRing ||
                    neighbour.value.bridgedRing &amp;&amp; neighbour.value.originalRings.length &lt; 2) {
                    vertex.value.isDrawn = false;
                }
            }
        }
    }
    /**
     * Returns all rings connected by bridged bonds starting from the ring with the supplied ring id.
     *
     * @param {Number} ringId A ring id.
     * @returns {Number[]} An array containing all ring ids of rings part of a bridged ring system.
     */
    getBridgedRingRings(ringId) {
        return this.ringManager.getBridgedRingRings(ringId);
    }
    /**
     * Checks whether or not a ring is part of a bridged ring.
     *
     * @param {Number} ringId A ring id.
     * @returns {Boolean} A boolean indicating whether or not the supplied ring (by id) is part of a bridged ring system.
     */
    isPartOfBridgedRing(ringId) {
        return this.ringManager.isPartOfBridgedRing(ringId);
    }
    /**
     * Creates a bridged ring.
     *
     * @param {Number[]} ringIds An array of ids of rings involved in the bridged ring.
     * @param {Number} sourceVertexId The vertex id to start the bridged ring discovery from.
     * @returns {Ring} The bridged ring.
     */
    createBridgedRing(ringIds, sourceVertexId) {
        return this.ringManager.createBridgedRing(ringIds, sourceVertexId);
    }
    /**
     * Checks whether or not two vertices are in the same ring.
     *
     * @param {Vertex} vertexA A vertex.
     * @param {Vertex} vertexB A vertex.
     * @returns {Boolean} A boolean indicating whether or not the two vertices are in the same ring.
     */
    areVerticesInSameRing(vertexA, vertexB) {
        return this.ringManager.areVerticesInSameRing(vertexA, vertexB);
    }
    /**
     * Returns an array of ring ids shared by both vertices.
     *
     * @param {Vertex} vertexA A vertex.
     * @param {Vertex} vertexB A vertex.
     * @returns {Number[]} An array of ids of rings shared by the two vertices.
     */
    getCommonRings(vertexA, vertexB) {
        return this.ringManager.getCommonRings(vertexA, vertexB);
    }
    /**
     * Returns the aromatic or largest ring shared by the two vertices.
     *
     * @param {Vertex} vertexA A vertex.
     * @param {Vertex} vertexB A vertex.
     * @returns {(Ring|null)} If an aromatic common ring exists, that ring, else the largest (non-aromatic) ring, else null.
     */
    getLargestOrAromaticCommonRing(vertexA, vertexB) {
        return this.ringManager.getLargestOrAromaticCommonRing(vertexA, vertexB);
    }
    /**
     * Returns an array of vertices positioned at a specified location.
     *
     * @param {Vector2} position The position to search for vertices.
     * @param {Number} radius The radius within to search.
     * @param {Number} excludeVertexId A vertex id to be excluded from the search results.
     * @returns {Number[]} An array containing vertex ids in a given location.
     */
    getVerticesAt(position, radius, excludeVertexId) {
        let locals = Array();
        for (var i = 0; i &lt; this.graph.vertices.length; i++) {
            let vertex = this.graph.vertices[i];
            if (vertex.id === excludeVertexId || !vertex.positioned) {
                continue;
            }
            let distance = position.distanceSq(vertex.position);
            if (distance &lt;= radius * radius) {
                locals.push(vertex.id);
            }
        }
        return locals;
    }
    /**
     * Returns the closest vertex (connected as well as unconnected).
     *
     * @param {Vertex} vertex The vertex of which to find the closest other vertex.
     * @returns {Vertex} The closest vertex.
     */
    getClosestVertex(vertex) {
        let minDist = 99999;
        let minVertex = null;
        for (var i = 0; i &lt; this.graph.vertices.length; i++) {
            let v = this.graph.vertices[i];
            if (v.id === vertex.id) {
                continue;
            }
            let distSq = vertex.position.distanceSq(v.position);
            if (distSq &lt; minDist) {
                minDist = distSq;
                minVertex = v;
            }
        }
        return minVertex;
    }
    /**
     * Add a ring to this representation of a molecule.
     *
     * @param {Ring} ring A new ring.
     * @returns {Number} The ring id of the new ring.
     */
    addRing(ring) {
        return this.ringManager.addRing(ring);
    }
    /**
     * Removes a ring from the array of rings associated with the current molecule.
     *
     * @param {Number} ringId A ring id.
     */
    removeRing(ringId) {
        this.ringManager.removeRing(ringId);
    }
    /**
     * Gets a ring object from the array of rings associated with the current molecule by its id. The ring id is not equal to the index, since rings can be added and removed when processing bridged rings.
     *
     * @param {Number} ringId A ring id.
     * @returns {Ring} A ring associated with the current molecule.
     */
    getRing(ringId) {
        return this.ringManager.getRing(ringId);
    }
    /**
     * Add a ring connection to this representation of a molecule.
     *
     * @param {RingConnection} ringConnection A new ringConnection.
     * @returns {Number} The ring connection id of the new ring connection.
     */
    addRingConnection(ringConnection) {
        return this.ringManager.addRingConnection(ringConnection);
    }
    /**
     * Removes a ring connection from the array of rings connections associated with the current molecule.
     *
     * @param {Number} ringConnectionId A ring connection id.
     */
    removeRingConnection(ringConnectionId) {
        this.ringManager.removeRingConnection(ringConnectionId);
    }
    /**
     * Removes all ring connections between two vertices.
     *
     * @param {Number} vertexIdA A vertex id.
     * @param {Number} vertexIdB A vertex id.
     */
    removeRingConnectionsBetween(vertexIdA, vertexIdB) {
        this.ringManager.removeRingConnectionsBetween(vertexIdA, vertexIdB);
    }
    /**
     * Get a ring connection with a given id.
     *
     * @param {Number} id
     * @returns {RingConnection} The ring connection with the specified id.
     */
    getRingConnection(id) {
        return this.ringManager.getRingConnection(id);
    }
    /**
     * Get the ring connections between a ring and a set of rings.
     *
     * @param {Number} ringId A ring id.
     * @param {Number[]} ringIds An array of ring ids.
     * @returns {Number[]} An array of ring connection ids.
     */
    getRingConnections(ringId, ringIds) {
        return this.ringManager.getRingConnections(ringId, ringIds);
    }
    /**
     * Returns the overlap score of the current molecule based on its positioned vertices. The higher the score, the more overlaps occur in the structure drawing.
     *
     * @returns {Object} Returns the total overlap score and the overlap score of each vertex sorted by score (higher to lower). Example: { total: 99, scores: [ { id: 0, score: 22 }, ... ]  }
     */
    getOverlapScore() {
        return this.overlapResolver.getOverlapScore();
    }
    /**
     * When drawing a double bond, choose the side to place the double bond. E.g. a double bond should always been drawn inside a ring.
     *
     * @param {Vertex} vertexA A vertex.
     * @param {Vertex} vertexB A vertex.
     * @param {Vector2[]} sides An array containing the two normals of the line spanned by the two provided vertices.
     * @returns {Object} Returns an object containing the following information: {
            totalSideCount: Counts the sides of each vertex in the molecule, is an array [ a, b ],
            totalPosition: Same as position, but based on entire molecule,
            sideCount: Counts the sides of each neighbour, is an array [ a, b ],
            position: which side to position the second bond, is 0 or 1, represents the index in the normal array. This is based on only the neighbours
            anCount: the number of neighbours of vertexA,
            bnCount: the number of neighbours of vertexB
        }
     */
    chooseSide(vertexA, vertexB, sides) {
        return this.overlapResolver.chooseSide(vertexA, vertexB, sides);
    }
    /**
     * Sets the center for a ring.
     *
     * @param {Ring} ring A ring.
     */
    setRingCenter(ring) {
        this.ringManager.setRingCenter(ring);
    }
    /**
     * Gets the center of a ring contained within a bridged ring and containing a given vertex.
     *
     * @param {Ring} ring A bridged ring.
     * @param {Vertex} vertex A vertex.
     * @returns {Vector2} The center of the subring that containing the vertex.
     */
    getSubringCenter(ring, vertex) {
        return this.ringManager.getSubringCenter(ring, vertex);
    }
    /**
     * Draw the actual edges as bonds to the canvas.
     *
     * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.
     */
    drawEdges(debug) {
        let that = this;
        let drawn = Array(this.graph.edges.length);
        drawn.fill(false);
        this.graph.traverseBF(0, function (vertex) {
            let edges = that.graph.getEdges(vertex.id);
            for (var i = 0; i &lt; edges.length; i++) {
                let edgeId = edges[i];
                if (!drawn[edgeId]) {
                    drawn[edgeId] = true;
                    that.drawEdge(edgeId, debug);
                }
            }
        });
        // Draw ring for implicitly defined aromatic rings
        if (!this.bridgedRing) {
            for (var i = 0; i &lt; this.rings.length; i++) {
                let ring = this.rings[i];
                if (this.isRingAromatic(ring)) {
                    this.canvasWrapper.drawAromaticityRing(ring);
                }
            }
        }
    }
    /**
     * Draw the an edge as a bonds to the canvas.
     *
     * @param {Number} edgeId An edge id.
     * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.
     */
    drawEdge(edgeId, debug) {
        let that = this;
        let edge = this.graph.edges[edgeId];
        let vertexA = this.graph.vertices[edge.sourceId];
        let vertexB = this.graph.vertices[edge.targetId];
        let elementA = vertexA.value.element;
        let elementB = vertexB.value.element;
        if ((!vertexA.value.isDrawn || !vertexB.value.isDrawn) &amp;&amp; this.opts.atomVisualization === 'default') {
            return;
        }
        let a = vertexA.position;
        let b = vertexB.position;
        let normals = this.getEdgeNormals(edge);
        // Create a point on each side of the line
        let sides = ArrayHelper.clone(normals);
        sides[0].multiplyScalar(10).add(a);
        sides[1].multiplyScalar(10).add(a);
        if (edge.bondType === '=' || this.getRingbondType(vertexA, vertexB) === '=' ||
            (edge.isPartOfAromaticRing &amp;&amp; this.bridgedRing)) {
            // Always draw double bonds inside the ring
            let inRing = this.areVerticesInSameRing(vertexA, vertexB);
            let s = this.chooseSide(vertexA, vertexB, sides);
            if (inRing) {
                // Always draw double bonds inside a ring
                // if the bond is shared by two rings, it is drawn in the larger
                // problem: smaller ring is aromatic, bond is still drawn in larger -> fix this
                let lcr = this.getLargestOrAromaticCommonRing(vertexA, vertexB);
                let center = lcr.center;
                normals[0].multiplyScalar(that.opts.bondSpacing);
                normals[1].multiplyScalar(that.opts.bondSpacing);
                // Choose the normal that is on the same side as the center
                let line = null;
                if (center.sameSideAs(vertexA.position, vertexB.position, Vector2.add(a, normals[0]))) {
                    line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
                }
                else {
                    line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
                }
                line.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength);
                // The shortened edge
                if (edge.isPartOfAromaticRing) {
                    this.canvasWrapper.drawLine(line, true);
                }
                else {
                    this.canvasWrapper.drawLine(line);
                }
                // The normal edge
                this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
            }
            else if (edge.center || vertexA.isTerminal() &amp;&amp; vertexB.isTerminal()) {
                normals[0].multiplyScalar(that.opts.halfBondSpacing);
                normals[1].multiplyScalar(that.opts.halfBondSpacing);
                let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
                let lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
                this.canvasWrapper.drawLine(lineA);
                this.canvasWrapper.drawLine(lineB);
            }
            else if (s.anCount == 0 &amp;&amp; s.bnCount > 1 || s.bnCount == 0 &amp;&amp; s.anCount > 1) {
                // Both lines are the same length here
                // Add the spacing to the edges (which are of unit length)
                normals[0].multiplyScalar(that.opts.halfBondSpacing);
                normals[1].multiplyScalar(that.opts.halfBondSpacing);
                let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
                let lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
                this.canvasWrapper.drawLine(lineA);
                this.canvasWrapper.drawLine(lineB);
            }
            else if (s.sideCount[0] > s.sideCount[1]) {
                normals[0].multiplyScalar(that.opts.bondSpacing);
                normals[1].multiplyScalar(that.opts.bondSpacing);
                let line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
                line.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength);
                this.canvasWrapper.drawLine(line);
                this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
            }
            else if (s.sideCount[0] &lt; s.sideCount[1]) {
                normals[0].multiplyScalar(that.opts.bondSpacing);
                normals[1].multiplyScalar(that.opts.bondSpacing);
                let line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
                line.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength);
                this.canvasWrapper.drawLine(line);
                this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
            }
            else if (s.totalSideCount[0] > s.totalSideCount[1]) {
                normals[0].multiplyScalar(that.opts.bondSpacing);
                normals[1].multiplyScalar(that.opts.bondSpacing);
                let line = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
                line.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength);
                this.canvasWrapper.drawLine(line);
                this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
            }
            else if (s.totalSideCount[0] &lt;= s.totalSideCount[1]) {
                normals[0].multiplyScalar(that.opts.bondSpacing);
                normals[1].multiplyScalar(that.opts.bondSpacing);
                let line = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
                line.shorten(this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength);
                this.canvasWrapper.drawLine(line);
                this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
            }
            else {
            }
        }
        else if (edge.bondType === '#') {
            normals[0].multiplyScalar(that.opts.bondSpacing / 1.5);
            normals[1].multiplyScalar(that.opts.bondSpacing / 1.5);
            let lineA = new Line(Vector2.add(a, normals[0]), Vector2.add(b, normals[0]), elementA, elementB);
            let lineB = new Line(Vector2.add(a, normals[1]), Vector2.add(b, normals[1]), elementA, elementB);
            this.canvasWrapper.drawLine(lineA);
            this.canvasWrapper.drawLine(lineB);
            this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
        }
        else if (edge.bondType === '.') {
            // TODO: Something... maybe... version 2?
        }
        else {
            let isChiralCenterA = vertexA.value.isStereoCenter;
            let isChiralCenterB = vertexB.value.isStereoCenter;
            if (edge.wedge === 'up') {
                this.canvasWrapper.drawWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));
            }
            else if (edge.wedge === 'down') {
                this.canvasWrapper.drawDashedWedge(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));
            }
            else {
                this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB));
            }
        }
        if (debug) {
            let midpoint = Vector2.midpoint(a, b);
            this.canvasWrapper.drawDebugText(midpoint.x, midpoint.y, 'e: ' + edgeId);
        }
    }
    /**
     * Draws the vertices representing atoms to the canvas.
     *
     * @param {Boolean} debug A boolean indicating whether or not to draw debug messages to the canvas.
     */
    drawVertices(debug) {
        for (var i = 0; i &lt; this.graph.vertices.length; i++) {
            let vertex = this.graph.vertices[i];
            let atom = vertex.value;
            let charge = 0;
            let isotope = 0;
            let bondCount = vertex.value.bondCount;
            let element = atom.element;
            let hydrogens = Atom.maxBonds[element] - bondCount;
            let dir = vertex.getTextDirection(this.graph.vertices);
            let isTerminal = this.opts.terminalCarbons || element !== 'C' || atom.hasAttachedPseudoElements ? vertex.isTerminal() : false;
            let isCarbon = atom.element === 'C';
            // This is a HACK to remove all hydrogens from nitrogens in aromatic rings, as this
            // should be the most common state. This has to be fixed by kekulization
            if (atom.element === 'N' &amp;&amp; atom.isPartOfAromaticRing) {
                hydrogens = 0;
            }
            if (atom.bracket) {
                hydrogens = atom.bracket.hcount;
                charge = atom.bracket.charge;
                isotope = atom.bracket.isotope;
            }
            // If the molecule has less than 3 elements, always write the "C" for carbon
            // Likewise, if the carbon has a charge or an isotope, always draw it
            if (charge || isotope || this.graph.vertices.length &lt; 3) {
                isCarbon = false;
            }
            if (this.opts.atomVisualization === 'allballs') {
                this.canvasWrapper.drawBall(vertex.position.x, vertex.position.y, element);
            }
            else if ((atom.isDrawn &amp;&amp; (!isCarbon || atom.drawExplicit || isTerminal || atom.hasAttachedPseudoElements)) || this.graph.vertices.length === 1) {
                if (this.opts.atomVisualization === 'default') {
                    this.canvasWrapper.drawText(vertex.position.x, vertex.position.y, element, hydrogens, dir, isTerminal, charge, isotope, this.graph.vertices.length, atom.getAttachedPseudoElements());
                }
                else if (this.opts.atomVisualization === 'balls') {
                    this.canvasWrapper.drawBall(vertex.position.x, vertex.position.y, element);
                }
            }
            else if (vertex.getNeighbourCount() === 2 &amp;&amp; vertex.forcePositioned == true) {
                // If there is a carbon which bonds are in a straight line, draw a dot
                let a = this.graph.vertices[vertex.neighbours[0]].position;
                let b = this.graph.vertices[vertex.neighbours[1]].position;
                let angle = Vector2.threePointangle(vertex.position, a, b);
                if (Math.abs(Math.PI - angle) &lt; 0.1) {
                    this.canvasWrapper.drawPoint(vertex.position.x, vertex.position.y, element);
                }
            }
            if (debug) {
                let value = 'v: ' + vertex.id + ' ' + ArrayHelper.print(atom.ringbonds);
                this.canvasWrapper.drawDebugText(vertex.position.x, vertex.position.y, value);
            }
            else {
                // this.canvasWrapper.drawDebugText(vertex.position.x, vertex.position.y, vertex.value.chirality);
            }
        }
        // Draw the ring centers for debug purposes
        if (this.opts.debug) {
            for (var j = 0; j &lt; this.rings.length; j++) {
                let center = this.rings[j].center;
                this.canvasWrapper.drawDebugPoint(center.x, center.y, 'r: ' + this.rings[j].id);
            }
        }
    }
    /**
     * Position the vertices according to their bonds and properties.
     */
    position() {
        let startVertex = null;
        // Always start drawing at a bridged ring if there is one
        // If not, start with a ring
        // else, start with 0
        for (var i = 0; i &lt; this.graph.vertices.length; i++) {
            if (this.graph.vertices[i].value.bridgedRing !== null) {
                startVertex = this.graph.vertices[i];
                break;
            }
        }
        for (var i = 0; i &lt; this.rings.length; i++) {
            if (this.rings[i].isBridged) {
                startVertex = this.graph.vertices[this.rings[i].members[0]];
            }
        }
        if (this.rings.length > 0 &amp;&amp; startVertex === null) {
            startVertex = this.graph.vertices[this.rings[0].members[0]];
        }
        if (startVertex === null) {
            startVertex = this.graph.vertices[0];
        }
        this.createNextBond(startVertex, null, 0.0);
    }
    /**
     * Stores the current information associated with rings.
     */
    backupRingInformation() {
        this.ringManager.backupRingInformation();
    }
    /**
     * Restores the most recently backed up information associated with rings.
     */
    restoreRingInformation() {
        this.ringManager.restoreRingInformation();
    }
    // TODO: This needs some cleaning up
    /**
     * Creates a new ring, that is, positiones all the vertices inside a ring.
     *
     * @param {Ring} ring The ring to position.
     * @param {(Vector2|null)} [center=null] The center of the ring to be created.
     * @param {(Vertex|null)} [startVertex=null] The first vertex to be positioned inside the ring.
     * @param {(Vertex|null)} [previousVertex=null] The last vertex that was positioned.
     * @param {Boolean} [previousVertex=false] A boolean indicating whether or not this ring was force positioned already - this is needed after force layouting a ring, in order to draw rings connected to it.
     */
    createRing(ring, center = null, startVertex = null, previousVertex = null) {
        this.ringManager.createRing(ring, center, startVertex, previousVertex);
    }
    /**
     * Rotate an entire subtree by an angle around a center.
     *
     * @param {Number} vertexId A vertex id (the root of the sub-tree).
     * @param {Number} parentVertexId A vertex id in the previous direction of the subtree that is to rotate.
     * @param {Number} angle An angle in randians.
     * @param {Vector2} center The rotational center.
     */
    rotateSubtree(vertexId, parentVertexId, angle, center) {
        this.overlapResolver.rotateSubtree(vertexId, parentVertexId, angle, center);
    }
    /**
     * Gets the overlap score of a subtree.
     *
     * @param {Number} vertexId A vertex id (the root of the sub-tree).
     * @param {Number} parentVertexId A vertex id in the previous direction of the subtree.
     * @param {Number[]} vertexOverlapScores An array containing the vertex overlap scores indexed by vertex id.
     * @returns {Object} An object containing the total overlap score and the center of mass of the subtree weighted by overlap score { value: 0.2, center: new Vector2() }.
     */
    getSubtreeOverlapScore(vertexId, parentVertexId, vertexOverlapScores) {
        return this.overlapResolver.getSubtreeOverlapScore(vertexId, parentVertexId, vertexOverlapScores);
    }
    /**
     * Returns the current (positioned vertices so far) center of mass.
     *
     * @returns {Vector2} The current center of mass.
     */
    getCurrentCenterOfMass() {
        return this.overlapResolver.getCurrentCenterOfMass();
    }
    /**
     * Returns the current (positioned vertices so far) center of mass in the neighbourhood of a given position.
     *
     * @param {Vector2} vec The point at which to look for neighbours.
     * @param {Number} [r=currentBondLength*2.0] The radius of vertices to include.
     * @returns {Vector2} The current center of mass.
     */
    getCurrentCenterOfMassInNeigbourhood(vec, r = this.opts.bondLength * 2.0) {
        return this.overlapResolver.getCurrentCenterOfMassInNeigbourhood(vec, r);
    }
    /**
     * Resolve primary (exact) overlaps, such as two vertices that are connected to the same ring vertex.
     */
    resolvePrimaryOverlaps() {
        this.overlapResolver.resolvePrimaryOverlaps();
    }
    /**
     * Resolve secondary overlaps. Those overlaps are due to the structure turning back on itself.
     *
     * @param {Object[]} scores An array of objects sorted descending by score.
     * @param {Number} scores[].id A vertex id.
     * @param {Number} scores[].score The overlap score associated with the vertex id.
     */
    resolveSecondaryOverlaps(scores) {
        this.overlapResolver.resolveSecondaryOverlaps(scores);
    }
    /**
     * Get the last non-null or 0 angle.
     * @param {Number} vertexId A vertex id.
     * @returns {Vertex} The last angle that was not 0 or null.
     */
    getLastAngle(vertexId) {
        while (vertexId) {
            let vertex = this.graph.vertices[vertexId];
            if (vertex.value.rings.length > 0) {
                // Angles from rings aren't useful to us...
                return 0;
            }
            if (vertex.angle) {
                return vertex.angle;
            }
            vertexId = vertex.parentVertexId;
        }
        return 0;
    }
    /**
     * Positiones the next vertex thus creating a bond.
     *
     * @param {Vertex} vertex A vertex.
     * @param {Vertex} [previousVertex=null] The previous vertex which has been positioned.
     * @param {Number} [angle=0.0] The (global) angle of the vertex.
     * @param {Boolean} [originShortest=false] Whether the origin is the shortest subtree in the branch.
     * @param {Boolean} [skipPositioning=false] Whether or not to skip positioning and just check the neighbours.
     */
    createNextBond(vertex, previousVertex = null, angle = 0.0, originShortest = false, skipPositioning = false) {
        if (vertex.positioned &amp;&amp; !skipPositioning) {
            return;
        }
        // If the double bond config was set on this vertex, do not check later
        let doubleBondConfigSet = false;
        // Keeping track of configurations around double bonds
        if (previousVertex) {
            let edge = this.graph.getEdge(vertex.id, previousVertex.id);
            if ((edge.bondType === '/' || edge.bondType === '\\') &amp;&amp; ++this.doubleBondConfigCount % 2 === 1) {
                if (this.doubleBondConfig === null) {
                    this.doubleBondConfig = edge.bondType;
                    doubleBondConfigSet = true;
                    // Switch if the bond is a branch bond and previous vertex is the first
                    // TODO: Why is it different with the first vertex?
                    if (previousVertex.parentVertexId === null &amp;&amp; vertex.value.branchBond) {
                        if (this.doubleBondConfig === '/') {
                            this.doubleBondConfig = '\\';
                        }
                        else if (this.doubleBondConfig === '\\') {
                            this.doubleBondConfig = '/';
                        }
                    }
                }
            }
        }
        // If the current node is the member of one ring, then point straight away
        // from the center of the ring. However, if the current node is a member of
        // two rings, point away from the middle of the centers of the two rings
        if (!skipPositioning) {
            if (!previousVertex) {
                // Add a (dummy) previous position if there is no previous vertex defined
                // Since the first vertex is at (0, 0), create a vector at (bondLength, 0)
                // and rotate it by 90
                let dummy = new Vector2(this.opts.bondLength, 0);
                dummy.rotate(MathHelper.toRad(-60));
                vertex.previousPosition = dummy;
                vertex.setPosition(this.opts.bondLength, 0);
                vertex.angle = MathHelper.toRad(-60);
                // Do not position the vertex if it belongs to a bridged ring that is positioned using a layout algorithm.
                if (vertex.value.bridgedRing === null) {
                    vertex.positioned = true;
                }
            }
            else if (previousVertex.value.rings.length > 0) {
                let neighbours = previousVertex.neighbours;
                let joinedVertex = null;
                let pos = new Vector2(0.0, 0.0);
                if (previousVertex.value.bridgedRing === null &amp;&amp; previousVertex.value.rings.length > 1) {
                    for (var i = 0; i &lt; neighbours.length; i++) {
                        let neighbour = this.graph.vertices[neighbours[i]];
                        if (ArrayHelper.containsAll(neighbour.value.rings, previousVertex.value.rings)) {
                            joinedVertex = neighbour;
                            break;
                        }
                    }
                }
                if (joinedVertex === null) {
                    for (var i = 0; i &lt; neighbours.length; i++) {
                        let v = this.graph.vertices[neighbours[i]];
                        if (v.positioned &amp;&amp; this.areVerticesInSameRing(v, previousVertex)) {
                            pos.add(Vector2.subtract(v.position, previousVertex.position));
                        }
                    }
                    pos.invert().normalize().multiplyScalar(this.opts.bondLength).add(previousVertex.position);
                }
                else {
                    pos = joinedVertex.position.clone().rotateAround(Math.PI, previousVertex.position);
                }
                vertex.previousPosition = previousVertex.position;
                vertex.setPositionFromVector(pos);
                vertex.positioned = true;
            }
            else {
                // If the previous vertex was not part of a ring, draw a bond based
                // on the global angle of the previous bond
                let v = new Vector2(this.opts.bondLength, 0);
                v.rotate(angle);
                v.add(previousVertex.position);
                vertex.setPositionFromVector(v);
                vertex.previousPosition = previousVertex.position;
                vertex.positioned = true;
            }
        }
        // Go to next vertex
        // If two rings are connected by a bond ...
        if (vertex.value.bridgedRing !== null) {
            let nextRing = this.getRing(vertex.value.bridgedRing);
            if (!nextRing.positioned) {
                let nextCenter = Vector2.subtract(vertex.previousPosition, vertex.position);
                nextCenter.invert();
                nextCenter.normalize();
                let r = MathHelper.polyCircumradius(this.opts.bondLength, nextRing.members.length);
                nextCenter.multiplyScalar(r);
                nextCenter.add(vertex.position);
                this.createRing(nextRing, nextCenter, vertex);
            }
        }
        else if (vertex.value.rings.length > 0) {
            let nextRing = this.getRing(vertex.value.rings[0]);
            if (!nextRing.positioned) {
                let nextCenter = Vector2.subtract(vertex.previousPosition, vertex.position);
                nextCenter.invert();
                nextCenter.normalize();
                let r = MathHelper.polyCircumradius(this.opts.bondLength, nextRing.getSize());
                nextCenter.multiplyScalar(r);
                nextCenter.add(vertex.position);
                this.createRing(nextRing, nextCenter, vertex);
            }
        }
        else {
            // Draw the non-ring vertices connected to this one  
            let isStereoCenter = vertex.value.isStereoCenter;
            let tmpNeighbours = vertex.getNeighbours();
            let neighbours = Array();
            // Remove neighbours that are not drawn
            for (var i = 0; i &lt; tmpNeighbours.length; i++) {
                if (this.graph.vertices[tmpNeighbours[i]].value.isDrawn) {
                    neighbours.push(tmpNeighbours[i]);
                }
            }
            // Remove the previous vertex (which has already been drawn)
            if (previousVertex) {
                neighbours = ArrayHelper.remove(neighbours, previousVertex.id);
            }
            let previousAngle = vertex.getAngle();
            if (neighbours.length === 1) {
                let nextVertex = this.graph.vertices[neighbours[0]];
                let prevEdge = previousVertex ? this.graph.getEdge(vertex.id, previousVertex.id) : null;
                let nextEdge = this.graph.getEdge(vertex.id, nextVertex.id);
                // Make a single chain always cis except when there's a tribble (yes, this is a Star Trek reference) bond
                // or if there are successive double bonds (or some other bond-heavy combo).
                if (prevEdge &amp;&amp; nextEdge &amp;&amp; prevEdge.weight + nextEdge.weight >= 4) {
                    prevEdge.center = true;
                    nextEdge.center = true;
                    // TODO: One of these is on value, but the other isn't?
                    vertex.value.drawExplicit = false;
                    nextVertex.drawExplicit = true;
                    nextVertex.angle = 0.0;
                    this.createNextBond(nextVertex, vertex, previousAngle + nextVertex.angle);
                }
                else if (previousVertex &amp;&amp; previousVertex.value.rings.length > 0) {
                    // If coming out of a ring, always draw away from the center of mass
                    let proposedAngleA = MathHelper.toRad(60);
                    let proposedAngleB = -proposedAngleA;
                    let proposedVectorA = new Vector2(this.opts.bondLength, 0);
                    let proposedVectorB = new Vector2(this.opts.bondLength, 0);
                    proposedVectorA.rotate(proposedAngleA).add(vertex.position);
                    proposedVectorB.rotate(proposedAngleB).add(vertex.position);
                    // let centerOfMass = this.getCurrentCenterOfMassInNeigbourhood(vertex.position, 100);
                    let centerOfMass = this.getCurrentCenterOfMass();
                    let distanceA = proposedVectorA.distanceSq(centerOfMass);
                    let distanceB = proposedVectorB.distanceSq(centerOfMass);
                    nextVertex.angle = distanceA &lt; distanceB ? proposedAngleB : proposedAngleA;
                    this.createNextBond(nextVertex, vertex, previousAngle + nextVertex.angle);
                }
                else {
                    let a = vertex.angle;
                    // Take the min and max if the previous angle was in a 4-neighbourhood (90 angles)
                    // TODO: If a is null or zero, it should be checked whether or not this one should go cis or trans, that is,
                    //       it should go into the oposite direction of the last non-null or 0 previous vertex / angle.
                    if (previousVertex &amp;&amp; previousVertex.neighbours.length > 3) {
                        if (a > 0) {
                            a = Math.min(1.0472, a);
                        }
                        else if (a &lt; 0) {
                            a = Math.max(-1.0472, a);
                        }
                        else {
                            a = 1.0472;
                        }
                    }
                    else if (!a) {
                        a = this.getLastAngle(vertex.id);
                        if (!a) {
                            a = 1.0472;
                        }
                    }
                    // Handle configuration around double bonds
                    if (previousVertex &amp;&amp; !doubleBondConfigSet) {
                        let bondType = this.graph.getEdge(vertex.id, nextVertex.id).bondType;
                        if (bondType === '/') {
                            if (this.doubleBondConfig === '/') {
                                // Nothing to do since it will be trans per default
                            }
                            else if (this.doubleBondConfig === '\\') {
                                a = -a;
                            }
                            this.doubleBondConfig = null;
                        }
                        else if (bondType === '\\') {
                            if (this.doubleBondConfig === '/') {
                                a = -a;
                            }
                            else if (this.doubleBondConfig === '\\') {
                                // Nothing to do since it will be trans per default
                            }
                            this.doubleBondConfig = null;
                        }
                    }
                    if (originShortest) {
                        nextVertex.angle = a;
                    }
                    else {
                        nextVertex.angle = -a;
                    }
                    this.createNextBond(nextVertex, vertex, previousAngle + nextVertex.angle);
                }
            }
            else if (neighbours.length === 2) {
                // If the previous vertex comes out of a ring, it doesn't have an angle set
                let a = vertex.angle;
                if (!a) {
                    a = 1.0472;
                }
                // Check for the longer subtree - always go with cis for the longer subtree
                let subTreeDepthA = this.graph.getTreeDepth(neighbours[0], vertex.id);
                let subTreeDepthB = this.graph.getTreeDepth(neighbours[1], vertex.id);
                let l = this.graph.vertices[neighbours[0]];
                let r = this.graph.vertices[neighbours[1]];
                l.value.subtreeDepth = subTreeDepthA;
                r.value.subtreeDepth = subTreeDepthB;
                // Also get the subtree for the previous direction (this is important when
                // the previous vertex is the shortest path)
                let subTreeDepthC = this.graph.getTreeDepth(previousVertex ? previousVertex.id : null, vertex.id);
                if (previousVertex) {
                    previousVertex.value.subtreeDepth = subTreeDepthC;
                }
                let cis = 0;
                let trans = 1;
                // Carbons go always cis
                if (r.value.element === 'C' &amp;&amp; l.value.element !== 'C' &amp;&amp; subTreeDepthB > 1 &amp;&amp; subTreeDepthA &lt; 5) {
                    cis = 1;
                    trans = 0;
                }
                else if (r.value.element !== 'C' &amp;&amp; l.value.element === 'C' &amp;&amp; subTreeDepthA > 1 &amp;&amp; subTreeDepthB &lt; 5) {
                    cis = 0;
                    trans = 1;
                }
                else if (subTreeDepthB > subTreeDepthA) {
                    cis = 1;
                    trans = 0;
                }
                let cisVertex = this.graph.vertices[neighbours[cis]];
                let transVertex = this.graph.vertices[neighbours[trans]];
                let edgeCis = this.graph.getEdge(vertex.id, cisVertex.id);
                let edgeTrans = this.graph.getEdge(vertex.id, transVertex.id);
                // If the origin tree is the shortest, make them the main chain
                let originShortest = false;
                if (subTreeDepthC &lt; subTreeDepthA &amp;&amp; subTreeDepthC &lt; subTreeDepthB) {
                    originShortest = true;
                }
                transVertex.angle = a;
                cisVertex.angle = -a;
                if (this.doubleBondConfig === '\\') {
                    if (transVertex.value.branchBond === '\\') {
                        transVertex.angle = -a;
                        cisVertex.angle = a;
                    }
                }
                else if (this.doubleBondConfig === '/') {
                    if (transVertex.value.branchBond === '/') {
                        transVertex.angle = -a;
                        cisVertex.angle = a;
                    }
                }
                this.createNextBond(transVertex, vertex, previousAngle + transVertex.angle, originShortest);
                this.createNextBond(cisVertex, vertex, previousAngle + cisVertex.angle, originShortest);
            }
            else if (neighbours.length > 0) {
                // Create vertices for all drawn neighbors...
                const vertices = neighbours.map(neighbour => {
                    let newvertex = this.graph.vertices[neighbour];
                    let subtreedepth = this.graph.getTreeDepth(neighbour, vertex.id);
                    newvertex.value.subtreeDepth = subtreedepth;
                    return newvertex;
                });
                // This puts all the longest subtrees on the far side...
                // TODO: Maybe try to balance this better?
                // KNOWN BUG: Sort comparator returns boolean instead of number.
                // JavaScript coerces false->0, true->1, effectively sorting in ascending order
                // (shortest subtrees first), opposite of what the comment suggests.
                // Correct would be: (a, b) => b.value.subtreeDepth - a.value.subtreeDepth
                // Preserving buggy behavior for backward compatibility during TypeScript migration.
                vertices.sort((a, b) => (a.value.subtreeDepth &lt; b.value.subtreeDepth));
                if (neighbours.length === 3 &amp;&amp;
                    previousVertex &amp;&amp;
                    previousVertex.value.rings.length &lt; 1 &amp;&amp;
                    vertices[2].value.rings.length &lt; 1 &amp;&amp;
                    vertices[1].value.rings.length &lt; 1 &amp;&amp;
                    vertices[0].value.rings.length &lt; 1 &amp;&amp;
                    vertices[2].value.subtreeDepth === 1 &amp;&amp;
                    vertices[1].value.subtreeDepth === 1 &amp;&amp;
                    vertices[0].value.subtreeDepth > 1) {
                    // Special logic for adding pinched crosses...
                    vertices[0].angle = -vertex.angle;
                    if (vertex.angle >= 0) {
                        vertices[1].angle = MathHelper.toRad(30);
                        vertices[2].angle = MathHelper.toRad(90);
                    }
                    else {
                        vertices[1].angle = -MathHelper.toRad(30);
                        vertices[2].angle = -MathHelper.toRad(90);
                    }
                    this.createNextBond(vertices[0], vertex, previousAngle + vertices[0].angle);
                    this.createNextBond(vertices[1], vertex, previousAngle + vertices[1].angle);
                    this.createNextBond(vertices[2], vertex, previousAngle + vertices[2].angle);
                }
                else {
                    // Divide the remaining space evenly among all neighbors...
                    const totalNeighbors = neighbours.length + (previousVertex ? 1 : 0);
                    const angleDelta = 2 * Math.PI / totalNeighbors;
                    let angle = angleDelta;
                    let index = 0;
                    if (neighbours.length % 2 !== 0) {
                        // If there are an even number, the longest neighbor goes directly across.
                        vertices[0].angle = 0.0;
                        this.createNextBond(vertices[0], vertex, previousAngle);
                        index = 1;
                    }
                    else {
                        // Otherwise, the two longest neighbors split the difference.
                        angle /= 2;
                    }
                    while (index &lt; neighbours.length) {
                        vertices[index + 0].angle = angle;
                        vertices[index + 1].angle = -angle;
                        this.createNextBond(vertices[index + 0], vertex, previousAngle + angle);
                        this.createNextBond(vertices[index + 1], vertex, previousAngle - angle);
                        angle += angleDelta;
                        index += 2;
                    }
                }
            }
        }
    }
    /**
     * Gets the vetex sharing the edge that is the common bond of two rings.
     *
     * @param {Vertex} vertex A vertex.
     * @returns {(Number|null)} The id of a vertex sharing the edge that is the common bond of two rings with the vertex provided or null, if none.
     */
    getCommonRingbondNeighbour(vertex) {
        return this.ringManager.getCommonRingbondNeighbour(vertex);
    }
    /**
     * Check if a vector is inside any ring.
     *
     * @param {Vector2} vec A vector.
     * @returns {Boolean} A boolean indicating whether or not the point (vector) is inside any of the rings associated with the current molecule.
     */
    isPointInRing(vec) {
        return this.ringManager.isPointInRing(vec);
    }
    /**
     * Check whether or not an edge is part of a ring.
     *
     * @param {Edge} edge An edge.
     * @returns {Boolean} A boolean indicating whether or not the edge is part of a ring.
     */
    isEdgeInRing(edge) {
        return this.ringManager.isEdgeInRing(edge);
    }
    /**
     * Check whether or not an edge is rotatable.
     *
     * @param {Edge} edge An edge.
     * @returns {Boolean} A boolean indicating whether or not the edge is rotatable.
     */
    isEdgeRotatable(edge) {
        let vertexA = this.graph.vertices[edge.sourceId];
        let vertexB = this.graph.vertices[edge.targetId];
        // Only single bonds are rotatable
        if (edge.bondType !== '-') {
            return false;
        }
        // Do not rotate edges that have a further single bond to each side - do that!
        // If the bond is terminal, it doesn't make sense to rotate it
        // if (vertexA.getNeighbourCount() + vertexB.getNeighbourCount() &lt; 5) {
        //   return false;
        // }
        if (vertexA.isTerminal() || vertexB.isTerminal()) {
            return false;
        }
        // Ringbonds are not rotatable
        if (vertexA.value.rings.length > 0 &amp;&amp; vertexB.value.rings.length > 0 &amp;&amp;
            this.areVerticesInSameRing(vertexA, vertexB)) {
            return false;
        }
        return true;
    }
    /**
     * Check whether or not a ring is an implicitly defined aromatic ring (lower case smiles).
     *
     * @param {Ring} ring A ring.
     * @returns {Boolean} A boolean indicating whether or not a ring is implicitly defined as aromatic.
     */
    isRingAromatic(ring) {
        return this.ringManager.isRingAromatic(ring);
    }
    /**
     * Get the normals of an edge.
     *
     * @param {Edge} edge An edge.
     * @returns {Vector2[]} An array containing two vectors, representing the normals.
     */
    getEdgeNormals(edge) {
        let v1 = this.graph.vertices[edge.sourceId].position;
        let v2 = this.graph.vertices[edge.targetId].position;
        // Get the normalized normals for the edge
        let normals = Vector2.units(v1, v2);
        return normals;
    }
    /**
     * Returns an array of vertices that are neighbouring a vertix but are not members of a ring (including bridges).
     *
     * @param {Number} vertexId A vertex id.
     * @returns {Vertex[]} An array of vertices.
     */
    getNonRingNeighbours(vertexId) {
        let nrneighbours = Array();
        let vertex = this.graph.vertices[vertexId];
        let neighbours = vertex.neighbours;
        for (var i = 0; i &lt; neighbours.length; i++) {
            let neighbour = this.graph.vertices[neighbours[i]];
            let nIntersections = ArrayHelper.intersection(vertex.value.rings, neighbour.value.rings).length;
            if (nIntersections === 0 &amp;&amp; neighbour.value.isBridge == false) {
                nrneighbours.push(neighbour);
            }
        }
        return nrneighbours;
    }
    /**
     * Annotaed stereochemistry information for visualization.
     */
    annotateStereochemistry() {
        this.stereochemistryManager.annotateStereochemistry();
    }
    /**
     *
     *
     * @param {Number} vertexId The id of a vertex.
     * @param {(Number|null)} previousVertexId The id of the parent vertex of the vertex.
     * @param {Uint8Array} visited An array containing the visited flag for all vertices in the graph.
     * @param {Array} priority An array of arrays storing the atomic numbers for each level.
     * @param {Number} maxDepth The maximum depth.
     * @param {Number} depth The current depth.
     */
    visitStereochemistry(vertexId, previousVertexId, visited, priority, maxDepth, depth, parentAtomicNumber = 0) {
        this.stereochemistryManager.visitStereochemistry(vertexId, previousVertexId, visited, priority, maxDepth, depth, parentAtomicNumber);
    }
    /**
     * Creates pseudo-elements (such as Et, Me, Ac, Bz, ...) at the position of the carbon sets
     * the involved atoms not to be displayed.
     */
    initPseudoElements() {
        for (var i = 0; i &lt; this.graph.vertices.length; i++) {
            const vertex = this.graph.vertices[i];
            const neighbourIds = vertex.neighbours;
            let neighbours = Array(neighbourIds.length);
            for (var j = 0; j &lt; neighbourIds.length; j++) {
                neighbours[j] = this.graph.vertices[neighbourIds[j]];
            }
            // Ignore atoms that have less than 3 neighbours, except if
            // the vertex is connected to a ring and has two neighbours
            if (vertex.getNeighbourCount() &lt; 3 || vertex.value.rings.length > 0) {
                continue;
            }
            // TODO: This exceptions should be handled more elegantly (via config file?)
            // Ignore phosphates (especially for triphosphates)
            if (vertex.value.element === 'P') {
                continue;
            }
            // Ignore also guanidine
            if (vertex.value.element === 'C' &amp;&amp; neighbours.length === 3 &amp;&amp;
                neighbours[0].value.element === 'N' &amp;&amp; neighbours[1].value.element === 'N' &amp;&amp; neighbours[2].value.element === 'N') {
                continue;
            }
            // Continue if there are less than two heteroatoms
            // or if a neighbour has more than 1 neighbour
            let heteroAtomCount = 0;
            let ctn = 0;
            for (var j = 0; j &lt; neighbours.length; j++) {
                let neighbour = neighbours[j];
                let neighbouringElement = neighbour.value.element;
                let neighbourCount = neighbour.getNeighbourCount();
                if (neighbouringElement !== 'C' &amp;&amp; neighbouringElement !== 'H' &amp;&amp;
                    neighbourCount === 1) {
                    heteroAtomCount++;
                }
                if (neighbourCount > 1) {
                    ctn++;
                }
            }
            if (ctn > 1 || heteroAtomCount &lt; 2) {
                continue;
            }
            // Get the previous atom (the one which is not terminal)
            let previous = null;
            for (var j = 0; j &lt; neighbours.length; j++) {
                let neighbour = neighbours[j];
                if (neighbour.getNeighbourCount() > 1) {
                    previous = neighbour;
                }
            }
            for (var j = 0; j &lt; neighbours.length; j++) {
                let neighbour = neighbours[j];
                if (neighbour.getNeighbourCount() > 1) {
                    continue;
                }
                neighbour.value.isDrawn = false;
                let hydrogens = Atom.maxBonds[neighbour.value.element] - neighbour.value.bondCount;
                let charge = '';
                if (neighbour.value.bracket) {
                    hydrogens = neighbour.value.bracket.hcount;
                    charge = neighbour.value.bracket.charge || 0;
                }
                vertex.value.attachPseudoElement(neighbour.value.element, previous ? previous.value.element : null, hydrogens, charge);
            }
        }
        // The second pass
        for (var i = 0; i &lt; this.graph.vertices.length; i++) {
            const vertex = this.graph.vertices[i];
            const atom = vertex.value;
            const element = atom.element;
            if (element === 'C' || element === 'H' || !atom.isDrawn) {
                continue;
            }
            const neighbourIds = vertex.neighbours;
            let neighbours = Array(neighbourIds.length);
            for (var j = 0; j &lt; neighbourIds.length; j++) {
                neighbours[j] = this.graph.vertices[neighbourIds[j]];
            }
            for (var j = 0; j &lt; neighbours.length; j++) {
                let neighbour = neighbours[j].value;
                if (!neighbour.hasAttachedPseudoElements || neighbour.getAttachedPseudoElementsCount() !== 2) {
                    continue;
                }
                const pseudoElements = neighbour.getAttachedPseudoElements();
                if (pseudoElements.hasOwnProperty('0O') &amp;&amp; pseudoElements.hasOwnProperty('3C')) {
                    neighbour.isDrawn = false;
                    vertex.value.attachPseudoElement('Ac', '', 0);
                }
            }
        }
    }
    get ringIdCounter() {
        return this.ringManager.ringIdCounter;
    }
    set ringIdCounter(value) {
        this.ringManager.ringIdCounter = value;
    }
    get ringConnectionIdCounter() {
        return this.ringManager.ringConnectionIdCounter;
    }
    set ringConnectionIdCounter(value) {
        this.ringManager.ringConnectionIdCounter = value;
    }
    get rings() {
        return this.ringManager.rings;
    }
    set rings(value) {
        this.ringManager.rings = value;
    }
    get ringConnections() {
        return this.ringManager.ringConnections;
    }
    set ringConnections(value) {
        this.ringManager.ringConnections = value;
    }
    get originalRings() {
        return this.ringManager.originalRings;
    }
    set originalRings(value) {
        this.ringManager.originalRings = value;
    }
    get originalRingConnections() {
        return this.ringManager.originalRingConnections;
    }
    set originalRingConnections(value) {
        this.ringManager.originalRingConnections = value;
    }
    get bridgedRing() {
        return this.ringManager.bridgedRing;
    }
    set bridgedRing(value) {
        this.ringManager.bridgedRing = value;
    }
}
module.exports = DrawerBase;
//# sourceMappingURL=DrawerBase.js.map</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Sun Nov 02 2025 13:44:30 GMT+1100 (Australian Eastern Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
